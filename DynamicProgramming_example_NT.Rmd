---
title: "Dynamic_programming_CaseStudy_Soetaert_Herman"
author: "Nick Triozzi"
date: "5/12/2020"
output: html_document
---

Code comes from Chapter 10 in Soetaert et al 2009:
Soetaert, Herman, and Herman, P. M. J. A Practical Guide to Ecological Modelling Using R as a Simulation Platform. Dordrecht]: Springer, 2009. Web.

Model is based on Clark and Mangel

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

The model is expressed in terms of biomass classes (x class) ranging between
a minimal (x crit) and maximal value (x max). Reproduction starts at a certain
biomass (x rep). The model is run for 20 time steps (times) ; the last time step is
the final condition.

```{r specify state vars and constraints}

x_crit <- 0 # critical mass to survive
x_crit <- 0 # critical mass to survive
x_max <- 160 # maximal mass
x_rep <- 4 # critical mass for reproduction
x_class <- x_crit:x_max # biomass classes
nmass <- length(x_class) # number of mass classes
t_max <- 50 # number of time steps
times <- 1:(t_max-1)

```


```{r}
# create df for wheat and barley yield generator
source("./R/wheat_yield.R")
source("./R/barley_yield.R")
wheatY=data.frame(year=seq(1:50), mean_yield=rpois(n=50, lambda = 30))
wheat_yield(wheatY) # generates wheat yield
barleyY=data.frame(year=seq(1:50), mean_yield=rpois(n=50, lambda = 45))
barley_yield(barleyY) # generates barley yield

npatch=4
good.b <- c(0, 0, 1.20, 1.80) # birthrates in good  year; cattle goats (current fitness)
good.d <- c(0, 0, 0.95, 0.85) # death rates in bad year; cattle goats (curent fitness)
bad.b <- c(0, 0, 1, 1.10)
bad.d <- c(0, 0, 0.65, 0.75)
# pop.r.g <- c(0, 0, 1.14, 1.53) # population growth good year (expected gains)
# pop.r.b <- c(0.65, 0.825)
goodyear <- c(0.25, 0.25, 0.8, 0.8)
hsr_cap <- c(160,160,160,160)
# pgoodyr.stock <- c(0.8, 0.8) # cows goats
# pbadyr.stock <- c(0.2, 0.2)
# pgoodyr.crop <- c(0.25, 0.25) # barley wheat
# pbadyr.crop <- c(0.75, 0.75)
hsr=36
theta=8

```

```{r specify state vars and constraints}
# # using Mace and Houston
# wcrit <- 0 # critical wealth, destitution point
# maxwealth <- 160 # in goat equivalents # maximal wealth
# hsr <- 80   #  critical wealth needed to survive
# theta <- 8 # number of goats obtained for one camel
# w_class <- wcrit:maxwealth # wealth classes
# nwealth <- length(w_class) # number of wealth classes
# t_max <- 50 # number of time steps
# times <- 1:(t_max-1)

```
Note the use of brackets surrounding t max-1 when we define the time sequence.
This is necessary, as the statement ‘1:t max-1’ is interpreted by R as
(1:t max)-1, or 0:(t max-1), which is not the same.
Animals can visit 3 different patches (npatch), each with different probability
of survival (psurvive), finding food (pfood), and with different costs (cost),
feeding gains (gain), and reproduction gains (repr).

During the dynamic programming operation, two matrices will be filled containing
the results. For each time step and biomass class they contain the optimal fitness
values (f) and the optimal decision (bestpatch). These matrices are initialized
as 0. One vector (V) records the fitness at the current time step and for each patch.

```{r }
f <- matrix(nrow=t_max,ncol=nmass ,0) # optimal fitness
bestpatch <- matrix(nrow=t_max-1,ncol=nmass-1,0) # best patch
V <- vector(length=npatch) # current fitness

```

Biomasses range from 0 (x crit) to 30 (x max), and increase with one for
each class. In R, matrices cannot start from an offset other than 1. Thus, f[1,t]
will contain the fitness for individuals with biomass 0 at time t, whilst f[31,t] will
contain the fitness of the last biomass class. As we may also need to calculate fitness
of animals with biomasses beyond 0 and 30, we make a function that performs the
correct cut-offs and retrieves the correct fitness value, for a biomass x and time
t, from f:

```{r }
fitness <- function(x,t)
{
xx <- pmin(x ,x_max)
xx <- pmax(xx,x_crit)
fitness <- f[t,xx-x_crit+1]
}
```



Note the use of pmin and pmax rather than min and max. In contrast to min
and max which return the maximum or minimum of all the values present in their
arguments, pmin and pmax can take several vectors (or matrices) as arguments.
Shorter arguments are recycled until they reach the same length as the longer arguments.
The functions return a single vector containing the ‘parallel’ maxima (or
minima) of the vectors. Thus, in the statement xx <- pmin(x ,x max) every
value of the vector x is compared with x max, and the vector xx will be equal to the
vector x, except that all values of x which exceed x max will have been replaced
by x max.

As dynamic programming models run backwards, the ‘initial condition’ is the
final value, here the fitness, at t max.
For this model, Clark and Mangel (2000) assume that the final fitness increases
with biomass, according to a Monod-like function (Section 2.5.3) with halfsaturation
coefficient kx and maximal fitness 60. The statement ‘f[ ,t max]<-’
changes all elements in the last column of f at once.

```{r}
# final fitness, at t max
# fend <- 60
# kx <- 0.25*x_max
# f[t_max,] <- fend*(x_class-x_crit)/(x_class-x_crit+kx)
f[t_max,] <- 36
```

The fitness value for the three patches, V, is calculated as the sum of the immediate
gain and the expected fitness of the next state.

```{r}
for (t in rev(times)) # backward in time
{
for (x in x_class[-1]) # for each class, except x-crit
{
  # seed <- x*invest.props
  # seed <- ifelse(seed>maxseed, maxseed, seed) # limit on seed plantable (implies fixed acreage)
  # wheatgain=seed/wheat_yield(yields = wheatY)*100 # wheat and barley gains are proportional to seed planted
  # barleygain=seed/barley_yield(yields = barleyY)*100
 
  #-- sets initial herd size/composition
  w <- x
  i <- seq(0,w/theta)
  for(y in 1: length(i)){
    ncattle <- i[y]*theta
    ngoats <- w-i[y]
    if(ncattle+ngoats>=hsr){
      d=0
    }
    if(ncattle+ngoats<hsr){
      d=hsr-(ncattle+ngoats)
    }
  wheatgain=wheat_yield(yields = wheatY)
  barleygain=barley_yield(yields = barleyY)
  cropgains <- c(wheatgain, barleygain, 0, 0) # variable crop gain
  cropcost <- c(cropgains/10) # crop cost is proportional to yield
    stock.t <- c(0, 0, ncattle, ngoats)
    allgains <- cropgains+stock.t
    dfit <- pmax(0,pmin(x-hsr,hsr_cap)) 
    
    expectedgain <- goodyear*(fitness( hsr- (good.b*stock.t) - (good.d*stock.t) + cropgains - cropcost -dfit , t+1)) + (1-goodyear)*(fitness(hsr- (bad.b*stock.t) - (bad.d*stock.t) + cropgains - cropcost - dfit, t+1))
    V <- expectedgain + dfit
  V[expectedgain == 0] <- 0 # destitute
  f[t,x-x_crit+1] <- max(V) # optimal fitness
  bestpatch[t,x-x_crit] <- which.max(V) # best patch
  }
}
}

  
  
  
  
  # good.stock.deaths <- c(0,0, stock.t*good.d)
  # bad.stock.deaths <- c(0, 0, stock.t*bad.d)

  # badgains <- c(cropgains, stock.t*pop.r.b)
  # badcosts <- c(cropcost, stock.t*bad.d)
  # pdrought <- c(pbadyr.crop, pbadyr.stock)
  # pnondrought <- c(pgoodyr.crop, pgoodyr.stock)
  
 
  }


#   
#   # cropgains <- pmax(0, pmin(x-minseed,cropyields)) 
# # dfit <- pmax(0,pmin(x-x_rep,repr)) # reproduction
#   
# expectgain <- psurvive*(pfood *fitness(x-cost+feedgain-dfit,t+1) +
# (1-pfood)*fitness(x-cost-dfit ,t+1) )
# V <- dfit + expectgain
# V[expectgain == 0] <- 0 # dead
# f[t,x-x_crit+1] <- max(V) # optimal fitness
# bestpatch[t,x-x_crit] <- which.max(V) # best patch
# } # next biomass class x
# } # next time t

```


```{r}
rates=list(Cbirthrate=0.6, Cdeathrate=0.1, Gbirthrate=0.7, Gdeathrate=0.25)
parms=list(w_class=w_class, theta=8, hsr=60, pB=0.2 )
sdp <- function(times, parms, rates){
  with(as.list(c(parms, rates)), {
    for (t in rev(times)) { # backward in time
      for (w in w_class[-1]) { # for each class, except x-crit
        for (i in 0:as.integer(w/theta)) {
          x=camels[t,w]*Cbirthrate - camels[t-1,w]*Cdeathrate
          y=goats[t,w]*Gbirthrate - goats[t-1,w]*Gdeathrate
          d= ifelse((x*theta)+y>=hsr,0,(hsr-(x*theta+y)))
          expectedreward <- (1-pB)*((i + (w-(i*theta)) + x + y) * wealth((x*theta)+y-d, t)) + pB*((i + (w-(i*theta)) + x + y) * wealth((x*theta)+y-d, t))
          V <- expectedreward-hsr
          V[expectedreward == 0] <- 0 # destitute
          f[t,w-wcrit+1] <- max(V) # optimal fitness
          bestpatch[t,w-wcrit] <- which.max(V) # best patch
        }
      }
    }
  })
}
sdp(times = times, parms = parms, rates = rates)
      
      goats <- ode(y=x,time=times, dexppop, parms=c(0.012))
      
      dfit <- pmax(0,pmin(x-x_rep,parms$repr)) # reproduction
      
      
      
      V <- dfit + expectgain
      V[expectgain == 0] <- 0 # dead
      f[t,x-x_crit+1] <- max(V) # optimal fitness
      bestpatch[t,w-wcrit] <- which.max(V) # best patch
      } # next biomass class x
  } # next time t
}
sdp(times = times, parms = parms)
  


```
The optimal patch selection (in matrix bestpatch) is finally depicted as a 2-D
image, and a legend added. It is simple to also add optimal fitness values, for each
time step and biomass class, as a contour plot.

```{r}
par(mfrow=c(1,1))
image(x=times,y=x_class[-
1],z=bestpatch,ylab="weight",xlab="time",zlim=c(0,3),
main="optimal patch",col=c("black","darkgrey","lightgrey","white"))
box()
legend("topleft",fill=c("black","darkgrey","lightgrey","white"),
legend=c("de ad","1","2","3"))
contour(x=1:t_max,y=x_class,z=f,add=TRUE)
legend("topright",legend="fitness",lty=1)
```





```{r}
par(mfrow=c(1,1))
image(x=times,y=x_class[-
1],z=bestpatch,ylab="weight",xlab="time",zlim=c(0,4),
main="optimal patch",col=c("red","green","blue","white", "black", "grey"))
box()
legend("topleft",fill=c("red","green","blue","white", "black", "grey"),
legend=c("de ad","1","2","3","4"))
contour(x=1:t_max,y=x_class,z=f,add=TRUE)
legend("topright",legend="fitness",lty=1)
```




