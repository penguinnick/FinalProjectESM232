---
title: "Gorchels_Triozzi_ESM232_final"
author: "Nick Triozzi"
date: "5/26/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
# load functions


```

## Agricultural component

Agricultural yields have great variation in the same crop by year, location, and farming strategies This makes greating a general yield function for a specific crop challenging. To address this, we have followed a similar approach to Gulland et al. 1996 by making our agricultural modeling component adaptable. This model uses an input dataframe with at least 30 years of yield data. This can either be specific data for the farm studied or averages in the area of interest. Like Gulland et al. 1996, our function uses a normal distribution to account for the variation and gives a simulated yield for each time step based on the presented data. 

#Example wheat data
```{r crops }
source("./R/wheat_yield.R")

source("./R/barley_yield.R")
#-- function for simulating crop yield data

wheat<-data.frame(year=seq(1,50), mean_yield=rpois(50,lambda = 67))
barley<-data.frame(year=seq(1,50), mean_yield=rpois(50,lambda = 74))


example_yields=read_csv("example_yield.csv")

wheat_input = example_yields %>% 
  select(year,yield_wheat) %>% 
  rename(mean_yield=yield_wheat)

wheat_yield(yields = wheat_input)

ggplot(wheat_input)+
  geom_histogram(aes(x=mean_yield), fill="burlywood3", binwidth = 0.25)+
  theme_classic()+
  ylab("Count")+
  xlab("Yield (tonnes/ha)")+
  scale_y_continuous(expand = c(0,0))
```

# Wheat Results 
```{r}

years = seq(from=1, to=100, by=1)
yield_res= sapply(years, wheat_yield, yields = wheat_input)
# keep track of what times we ran
yield_den = data.frame(yield=yield_res, years=years)

ggplot(yield_den)+
  geom_histogram(aes(x=yield), fill="burlywood3")+
  theme_classic()+
  ylab("Count")+
  xlab("Wheat Yield (tonnes/ha)")+
  scale_y_continuous(expand = c(0,0))

```


#Barley Results 

```{r}
source("./R/barley_yield.R")

example_yields=read_csv("example_yield.csv")

barley_input = example_yields %>% 
  select(year,yield_barley) %>% 
  rename(mean_yield=yield_barley)

barley_yield(yields = barley_input)


yield_res_b= sapply(years, barley_yield, yields = barley_input)
# keep track of what times we ran
yield_den_b = data.frame(yield=yield_res_b, years=years)

ggplot(yield_den_b)+
  geom_histogram(aes(x=yield), fill="burlywood4")+
  theme_classic()+
  ylab("Count")+
  xlab("Barley Yield (tonnes/ha)")+
  scale_y_continuous(expand = c(0,0))


```


## Livestock component

We're only interested in herd growth during one time step, and input parameters, especially fertility and survivability might be modified depending on the goals of the farmer. Here, we've modified the function evolve_pop to account for additional herd reductions from slaughter. Two offtake rates are considered: 50% and 75% use rates for exploiting natural deaths for caloric gain. These figures variably affect different age categories each with its own fertility rate. Offtake for slaughter may have down-the-line consequences for herd size. 

```{r livestock, echo=FALSE}

source("./R/evolve_pop_wofftakeK.R")

nyears=50
nyears=nyears
# assign values for fertility for each of the age classes 
# number of daughters expected at age x from females still alive at age x
goatfert =  c(0,0.150,0.410,0.550,0.705, 0.695, 0.725, 0.515,0.515)
fertility = goatfert

# survivability - based on mortality rates female sheep (Redding Table IV-7)
goatsurv <- c(0.55, 0.90, 0.90, 0.95, 0.95, 0.90, 0.75, 0.50, 0.00)
survivability <- goatsurv

# initial population parameters
p0 = c(48, 23, 19, 15, 13, 12, 9, 6, 3)
goatini=p0
initialpop = goatini


tmp<-evolve_pop_wofftake(fertility = fertility, survivability = survivability,initialpop = p0, nstep = nyears, offtake = 0.75, K=220, minHerd = 140) 

str(tmp)
```



```{r plot livestock, echo=FALSE}
# test two offtake rates
offtakerate= c(0.50, 0.75)

tmp<-lapply(offtakerate, function(o){tmp=evolve_pop_wofftake(fertility, survivability, p0, nstep = nyears, offtake = o, extrinsicP = 0.97, K=320, minHerd = sum(p0)); return(tmp)})

# total offtake per year
yrs=seq(1:(nyears-1))
s=1:length(offtakerate)
tot.annual.offtake = sapply(s, function(s){sapply(yrs, function(y){sum(tmp[[s]]$offtakes[,y])})})
tot.annual.offtake

#-- compare population trends for both strategies 
goat50=cbind.data.frame(year=seq(1:nyears), t(tmp[[1]]$popbyage))
goat75=cbind.data.frame(year=seq(1:nyears), t(tmp[[2]]$popbyage))

agecats <- c("year", "0-1", "1-2", "2-3", "3-4", "4-5", "5-6", "6-7", "7-8", "8-9")
colnames(goat50)<- agecats
colnames(goat75)<- agecats

goat50_agesl= goat50 %>% gather(key="agecat", value="pop",-year)
goat75_agesl= goat75 %>% gather(key="agecat", value="pop",-year)

# plots
ggplot(goat50_agesl, aes(year, pop, fill=agecat))+geom_col()+labs(y="Population", fill="Age Group")+
  theme_classic()+
  scale_y_continuous(expand = c(0,0))

ggplot(goat75_agesl, aes(year, pop, fill=agecat))+geom_col()+labs(y="Population", fill="Age Group")+
  theme_classic()+
  scale_y_continuous(expand = c(0,0))
```
#-- compare offtake trends for both strategies 
```{r}
#-- compare offtake trends for both strategies 
goat50off=cbind.data.frame(year=seq(2:nyears), t(tmp[[1]]$offtakes))
goat75off=cbind.data.frame(year=seq(2:nyears), t(tmp[[2]]$offtakes))
colnames(goat50off)<- agecats 
colnames(goat75off)<- agecats
goat50_agesl_off= goat50off %>% gather(key="agecat", value="slaughtered",-year)
goat75_agesl_off= goat75off %>% gather(key="agecat", value="slaughtered",-year)

# plots

### Facet wrap woul be nice here
ggplot(goat50_agesl_off, aes(year, slaughtered, fill=agecat))+
  geom_col()+
  labs(y="Animals available for slaughter", fill="Age Group")+
  theme_classic()+
  scale_y_continuous(expand = c(0,0))

ggplot(goat75_agesl_off, aes(year, slaughtered, fill=agecat))+
  geom_col()+labs(y="Animals available for slaughter", fill="Age Group")+
  theme_classic()+
  scale_y_continuous(expand = c(0,0))

```

## over the 50 year period, which strategy obtains more meat?
```{r }
#-- over the 50 year period, which strategy obtains more meat?
s <- c(1,2)
y <- seq(1:ncol(tmp[[1]]$offtakes))
ot.yr <- sapply(s, function(s){sapply(yrs, function(y){sum(tmp[[s]]$offtakes[,y])})})
ot.df <- as.data.frame(ot.yr)
colnames(ot.df) <- c("g50", "g75")
ot.yr <- ot.df%>% gather(key="userate", value="annual.total")

ggplot(ot.yr, aes(userate, annual.total)) + geom_boxplot() + 
  labs(title ="Total offtakes per year for each strategy", subtitle = "Carrying Capacity=200, Min herd size=160")
```

## A 50% use of naturally occuring herd deaths results in more animals available for offtake over a 50-year period

```{r }
#-- A 50% use of naturally occuring herd deaths results in more animals available for offtake over a 50-year period
newstock <- data.frame(g50=tmp[[1]]$newstock, g75=tmp[[2]]$newstock)
head(newstock)
newstock <- newstock[-1,]%>% gather(key="newstock", value="count")
ggplot(newstock, aes(newstock, count)) + geom_boxplot() + ggtitle("Annual Births for each strategy")



```



```{r sensitivity livestock}
compute.offtake.metrics <- function(res){
  s=1:length(res)
  yrs=1:ncol(res[[1]]$offtakes)
  tot.annual.offtake = sapply(s, function(s){sapply(yrs, function(y){sum(tmp[[s]]$offtakes[,y])})})
  avg.annual.offtake = sapply(s, function(s){mean(tot.annual.offtake[,s])})
  return(avg.annual.offtake)
  # return(tot.annual.offtake)
}
compute.offtake.metrics(tmp)

```

```{r Livestock sensitivity analysis}
library(sensitivity)

source("./R/evolve_pop_wofftakeK.R")

evolve_pop_wofftake(fertility, survivability, p0, nstep = nyears, offtake = 0.50, K=220, minHerd = 160)
np=100
Off <- rnorm(mean = 0.5, sd=0.25, n=np)
K <- rnorm(mean = 220, sd=60, n=np)
minHerd <- rnorm(mean = 160, sd=30, n=np)
X1 = cbind.data.frame(Off=Off, K=K, minHerd=minHerd)

np=100
Off <- rnorm(mean = 0.5, sd=0.25, n=np)
K <- rnorm(mean = 220, sd=60, n=np)
minHerd <- rnorm(mean = 160, sd=30, n=np)
X2 = cbind.data.frame(Off=Off, K=K, minHerd=minHerd)

# null model
sens_P_livestock = sobol2007(model = NULL, X1,X2, nboot =300)

# wrapper function to summarize average number of animals slaughtered per year
avg.offtakes <- function(res){
  alist <- res[3,]
  annavgs=lapply(alist, function(a){ann.totals=mean(apply(a,2,FUN = sum))})
  return(annavgs)
}

res = unlist(avg.offtakes(mapply(FUN = evolve_pop_wofftake, offtake=sens_P_livestock$X$Off, K=sens_P_livestock$X$K, minHerd=sens_P_livestock$X$minHerd, MoreArgs = list(fertility, survivability, p0, nstep=nyears)))) #; return(compute.offtake.metrics(tmp))})

sens_P_livestock = sensitivity::tell(sens_P_livestock, unlist(res), res.names="avg.ann.offtake")

sens_P_livestock$S
sens_P_livestock$T

print(sens_P_livestock)
plot(sens_P_livestock, ylim = c(-3,4))

# making a datafram for plotting
both = cbind.data.frame(sens_P_livestock$X, results=sens_P_livestock$y)

# look at response of conductance to the two most important variables
ggplot(both, aes(Off,results, col=K))+geom_point()+labs(y="average animals slaughtered annually", x="offtake rate") + ggtitle("Results of sensitivity analysis of results of livestock submodel")

# Looking at the response to the two most important variables
ggplot(both, aes(minHerd, results, col = K)) +
  geom_point() +
  labs(x = "min herd size", y ="average animals slaughtered annually") +
  theme_classic()

```

## The Farmer's Choice Model

A 50% use of naturally occuring herd deaths results in more animals available for offtake over a 50-year period. We'll use stochastic dynamic programming (sdp) to determine if 50% use rate is the optimal strategy when paired with variable cropping strategies

Here we create lists containing the parameters for the sdp function. There are two state variables: wealth which is a measure of fitness, and age-structured goat herd population. At the start of each time step, a farmer decides whether to sow wheat (a drought sensitive crop) or barley (a drought resistant crop). The average yields are based on a poisson distribution, and is calculated as shown above. Depending on the yield, a cost to wealth is incurred reflecting seed, and is proportional to the yield. If the farmers wealth during the previous timestep is greater than the seed cost, the gains from planting either wheat or barley can be expected. The probability of obtaining any yield is based on a poisson distribution. 


```{r sdp model, echo=FALSE}
nyears=50

parms= list(x_crit=0, # critical mass to survive
            x_max=75, # maximal mass
            t_max=50,
            maxwealth=75) # number of time steps) 


parms= list(x_crit=0, # critical mass to survive
            x_max=15, # maximal mass
            t_max=30,
            maxwealth=15) # number of time steps) 
#-- stock and crop parms from above
stock.parms= list(offtake=offtakerate, fertility=fertility, survivability=survivability, nstocks=2, initialpop=p0)
crop.parms=list(wheatY=wheat, barleyY=barley, wl=67, bl=74, ncrops=2)

# source("./R/sdp_farm123.R")
# source("./R/sdp_farm123.R")
# run function    
sdp.out=sdp_farm(parms = parms, crop.parms = crop.parms, stock.parms = stock.parms)

sdp_df=function(sdp.out,crop.parms = crop.parms, stock.parms=stock.parms){
  fw<- sdp.out$FarmWealth
  bp<- sdp.out$OptimalStrategy
  gp<- sdp.out$GoatPop
  # a=apply(gp, c(3,1), matrix)
  # b=sapply(1:75, function(s){sapply(1:nyears, function(n){sum(a[n,,s])})})
  # mean.herd<- apply(b, 1, mean)
  
  farm.yrly<- data.frame(year=1:nyears, 
                         avg.wealth=apply(fw,1 ,mean), 
                         sd.wealth=apply(fw,1 ,sd),
                         wheat.yld=crop.parms$wheatY$mean_yield,
                         barley.yld=crop.parms$barleyY$mean_yield)
                         # mean.herd=mean.herd[-50]) 
  return(farm.yrly)
}

# as a dataframe
farm.yrly=sdp_df(sdp.out)
head(farm.yrly)
# crops <- gather(farm.yrly[-50,c(4,5)],value = "yield", key = "crop")

gg1<-ggplot(farm.yrly[-50,], aes(x=year,y=avg.wealth))+geom_line() 
gg1 + geom_point(aes(y=wheat.yld), color="red") +
  geom_point(aes(y=barley.yld), color="blue") 

compute.metrics= function(df){
  df=df[-50,]
    
  return(list(mean.wealth=mean(df$avg.wealth),
              variance=var(df$avg.wealth),
              cor.wheat=cor(df$wheat.yld, df$avg.wealth),
              cor.barley=cor(df$barley.yld, df$avg.wealth)))
}
compute.metrics(farm.yrly)              


```


```{r }
# plot
plot.wealth <- function(sdp.out, farm.yrly){
  w=0:ncol(sdp.out$FarmWealth[,-1])
  t=1:nrow(sdp.out$OptimalStrategy)
  # par(mfrow=c(1,1))
  par(xpd = T, mar = par()$mar + c(0,0,0,12))
  image(x=t,y=w[-1],z=bestpatch,ylab="Wealth",xlab="Time",zlim=c(0,5),
        main="Best Strategy",col=c("black",topo.colors(4)))
  box() 
  legend(55, 25, fill=c("black",topo.colors(4), "red"), legend=c("destitue","wheat & 50% use rate","wheat & 75% use rate","barley & 50% use rate", "barley & 75% use rate", "mean wealth"))
  contour(x=1:parms$t_max,y=wealthclasses,z=f1,add=TRUE)
  abline(h = mean(farm.yrly$avg.wealth), col="red", lwd=3, lty=2)
}
plot.wealth(sdp.out, farm.yrly)
```


```{r}

# class.res=
gp %>% group_by(1)
dimnames(goat.pop)
apply(gp, c(3) , sum)
data.frame(class=c(1:ncol(f1)), avg.wealth=apply(f1,2 ,mean))
data.frame(year=c(1:nyears), avg.wealth=apply(f1,1 ,mean))
  
}
```

## that's a noisy graph. 
We try again byt change a few parameters.

```{r changing params}
crop.parms=list(wheatY=wheat, barleyY=barley, ncrops=2)
sdp.out=sdp_farm(parms = parms, crop.parms = crop.parms, mean.ylds = c(58,58), stock.parms = stock.parms, hsr = 8)

f1<-sdp.out$FarmWealth
bestpatch <- sdp.out$OptimalStrategy

# show optimal strategy
plot.wealth(sdp.out, farm.yrly)

wealthclasses=0:ncol(sdp.out$FarmWealth[,-1])
timesteps = 1:nrow(sdp.out$OptimalStrategy)

# plot

par(mfrow=c(1,1))
image(x=timesteps,y=wealthclasses[-1],z=bestpatch,ylab="Wealth",xlab="Time",zlim=c(0,5), main="Best Strategy",col=c("black",topo.colors(4))) 
box() 
# legend("topleft",fill=c("black",topo.colors(4)), legend=c("destitue","wheat & 50% use rate","wheat & 75% use rate","barley & 50% use rate", "barley & 75% use rate")) 
contour(x=1:parms$t_max,y=wealthclasses,z=f1,add=TRUE) 
# legend("topright",legend="Wealth",lty=1)


```

```{r summarizing sdp res}

## SDP Sensitivity analysis


```


```{r set up for sdp2, echo=FALSE}
library(sensitivity)
(parms, crop.parms, stock.parms,hsr=36,max_store=20,PrS=0.85,PrGood=0.8,D.good=0.75,D.bad=0.85)
# names of our parameters
# number of parameters 

np=100
hsr = rnorm(mean=36,sd=12, n=np)
max_store = runif(min=12,max=30, n=np)
PrS = rnorm(mean=0.85, sd=0.30, n=np)
PrGood = rnorm(mean=0.8, sd=0.25, n=np)
D.good = rnorm(mean=0.75, sd=0.15, n=np)
D.bad = rnorm(mean=0.85, sd=0.35, n=np)
X1 = cbind.data.frame(hsr, max_store, PrS, PrGood, D.good, D.bad)

# generate two examples of random number from parmeter distributions

# repeat sampling
np=100
hsr = rnorm(mean=36,sd=12, n=np)
max_store = runif(min=12,max=30, n=np)
PrS = rnorm(mean=0.85, sd=0.30, n=np)
PrGood = rnorm(mean=0.8, sd=0.25, n=np)
D.good = rnorm(mean=0.75, sd=0.15, n=np)
D.bad = rnorm(mean=0.85, sd=0.35, n=np)
X2 = cbind.data.frame(hsr, max_store, PrS, PrGood, D.good, D.bad)

sens_sdp_sobel = sobol2007(model = NULL, X1, X2, nboot = 100)

# wrapper function for summarizing sdp results


# run model for all parameter sets
sdp_res = mapply(FUN=sdp_farm,  hsr=sens_sdp_sobel$X$hsr, max_store=sens_sdp_sobel$X$max_store, PrS=sens_sdp_sobel$X$PrS, PrGood=sens_sdp_sobel$X$PrGood, D.good=sens_sdp_sobel$X$D.good, D.bad=sens_sdp_sobel$X$D.bad, MoreArgs=list(parms=parms, crop.parms=crop.parms, stock.parms=stock.parms))


sens_sdp_sobel = sensitivity::tell(sens_sdp_sobel,res, res.names="ga")

# first-order indices (main effect without co-variance)
sens_Catm_sobel$S

# total sensitivity index -note that this partitions the output variance - so values sum to 1
sens_Catm_sobel$T

# The difference between the main effect and total effect can tell us something about how the parameter influences results
# so in the main effect we include interactions with other parameters


print(sens_Catm_sobel)
plot(sens_Catm_sobel)

# compare with LHS and PRCC
sens_Catm$prcc


sens_Catm_sobel$S
sens_Catm_sobel$T

# make a data frame for plotting
both = cbind.data.frame(sens_Catm_sobel$X, gs=sens_Catm_sobel$y)

# look at response of conductance to the two most important variables
ggplot(both, aes(v,gs, col=height))+geom_point()+labs(y="Conductance (mm/s)", x="Windspeed")


```
##References 
Milner-Gulland, E.J., Mace, R., Scoones, I.1996."A Model of Household Deciscions in Dryland Agropastoral Systems".Agricultral Systems. 51:4, 407-430.


