---
title: "Dynamic_programming_CaseStudy_Soetaert_Herman"
author: "Nick Triozzi"
date: "5/12/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

The model is expressed in terms of biomass classes (x class) ranging between
a minimal (x crit) and maximal value (x max). Reproduction starts at a certain
biomass (x rep). The model is run for 20 time steps (times) ; the last time step is
the final condition.

```{r specify state vars and constraints}

x_crit <- 0 # critical mass to survive
x_max <- 30 # maximal mass
x_rep <- 4 # critical mass for reproduction
x_class <- x_crit:x_max # biomass classes
nmass <- length(x_class) # number of mass classes
t_max <- 20 # number of time steps
times <- 1:(t_max-1)

```

Note the use of brackets surrounding t max-1 when we define the time sequence.
This is necessary, as the statement ‘1:t max-1’ is interpreted by R as
(1:t max)-1, or 0:(t max-1), which is not the same.
Animals can visit 3 different patches (npatch), each with different probability
of survival (psurvive), finding food (pfood), and with different costs (cost),
feeding gains (gain), and reproduction gains (repr).

```{r pressure, echo=FALSE}
npatch <- 3 # number of patches
psurvive <- c(0.99,0.95,0.98) # probability of surviving
pfood <- c(0.2 ,0.5 ,0 ) # probability of feeding
cost <- c(1 ,1 ,1 ) # cost of a patch
feedgain <- c(2 ,4 ,0 ) # gain of feeding
repr <- c(0 ,0 ,4 ) # max reproduction

```

During the dynamic programming operation, two matrices will be filled containing
the results. For each time step and biomass class they contain the optimal fitness
values (f) and the optimal decision (bestpatch). These matrices are initialized
as 0. One vector (V) records the fitness at the current time step and for each patch.

```{r }
f <- matrix(nrow=t_max,ncol=nmass ,0) # optimal fitness
bestpatch <- matrix(nrow=t_max-1,ncol=nmass-1,0) # best patch
V <- vector(length=npatch) # current fitness

```

Biomasses range from 0 (x crit) to 30 (x max), and increase with one for
each class. In R, matrices cannot start from an offset other than 1. Thus, f[1,t]
will contain the fitness for individuals with biomass 0 at time t, whilst f[31,t] will
contain the fitness of the last biomass class. As we may also need to calculate fitness
of animals with biomasses beyond 0 and 30, we make a function that performs the
correct cut-offs and retrieves the correct fitness value, for a biomass x and time
t, from f:

```{r }
fitness <- function(x,t)
{
xx <- pmin(x ,x_max)
xx <- pmax(xx,x_crit)
fitness <- f[t,xx-x_crit+1]
}
```

Note the use of pmin and pmax rather than min and max. In contrast to min
and max which return the maximum or minimum of all the values present in their
arguments, pmin and pmax can take several vectors (or matrices) as arguments.
Shorter arguments are recycled until they reach the same length as the longer arguments.
The functions return a single vector containing the ‘parallel’ maxima (or
minima) of the vectors. Thus, in the statement xx <- pmin(x ,x max) every
value of the vector x is compared with x max, and the vector xx will be equal to the
vector x, except that all values of x which exceed x max will have been replaced
by x max.
As dynamic programming models run backwards, the ‘initial condition’ is the
final value, here the fitness, at t max.
For this model, Clark and Mangel (2000) assume that the final fitness increases
with biomass, according to a Monod-like function (Section 2.5.3) with halfsaturation
coefficient kx and maximal fitness 60. The statement ‘f[ ,t max]<-’
changes all elements in the last column of f at once.

```{r}
# final fitness, at t max
fend <- 60
kx <- 0.25*x_max
f[t_max,] <- fend*(x_class-x_crit)/(x_class-x_crit+kx)
```

The fitness value for the three patches, V, is calculated as the sum of the immediate
gain and the expected fitness of the next state.

```{r}

for (t in rev(times)) # backward in time
{
for (x in x_class[-1]) # for each class, except x-crit
{
dfit <- pmax(0,pmin(x-x_rep,repr)) # reproduction
expectgain <- psurvive*(pfood *fitness(x-cost+feedgain-dfit,t+1) +
(1-pfood)*fitness(x-cost-dfit ,t+1) )
V <- dfit + expectgain
V[expectgain == 0] <- 0 # dead
f[t,x-x_crit+1] <- max(V) # optimal fitness
bestpatch[t,x-x_crit] <- which.max(V) # best patch
} # next biomass class x
} # next time t

```

The optimal patch selection (in matrix bestpatch) is finally depicted as a 2-D
image, and a legend added. It is simple to also add optimal fitness values, for each
time step and biomass class, as a contour plot.

```{r}
par(mfrow=c(1,1))
image(x=times,y=x_class[-
1],z=bestpatch,ylab="weight",xlab="time",zlim=c(0,3),
main="optimal patch",col=c("black","darkgrey","lightgrey","white"))
box()
legend("topleft",fill=c("black","darkgrey","lightgrey","white"),
legend=c("de ad","1","2","3"))
contour(x=1:t_max,y=x_class,z=f,add=TRUE)
legend("topright",legend="fitness",lty=1)
```










